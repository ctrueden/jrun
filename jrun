#!/bin/sh

# A script to execute a main class of a Maven artifact
# which is available locally or from Maven Central.
#
# Works using the maven-dependency-plugin to stash the artifact
# and its deps to a temporary location, then invokes java.
#
# It would be more awesome to enhance the exec-maven-plugin to support
# running something with a classpath built from the local Maven repository
# cache. Then you would get all the features of exec-maven-plugin.
# But this script works in a pinch for simple cases.

# Useful functions.

die() { echo "$@" 1>&2; exit 1; }

trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"
    var="${var%"${var##*[![:space:]]}"}"
    echo "$var"
}

# Parse configuration file.

configFile="$HOME/.jrunrc"
l=1
repositories=()
shortcuts=()

test -f "$configFile" &&
while read line
do
	let "l++"
	case "$line" in
		'#'*)
			# skip comment
			;;
		\[*\])
			ltrim="${line:1}"
			section="${ltrim%?}"
			;;
		*=*)
			case "$section" in
				repositories)
					repositories+=("$line")
					;;
				shortcuts)
					shortcuts+=("$line")
					;;
				*)
					;;
			esac
			;;
	esac
done <"$configFile"

# Parse arguments.

jvm_args=()
app_args=()
while test $# -gt 0
do
	case "$1" in
	-*)
		test -z "$endpoint" && jvm_args+=("$1") || app_args+=("$1")
		;;
	*)
		test -z "$endpoint" && endpoint="$1" || app_args+=("$1")
		;;
	esac
	shift
done

# Parse the endpoint.

for shortcut in "${shortcuts[@]}"
do
	key=$(trim "${shortcut%=*}")
	val=$(trim "${shortcut#*=}")
	case "$endpoint" in
		$key*)
			endpoint="$val${endpoint#$key}"
			;;
	esac
done

case "$endpoint" in
	*:*:*:*:*:*) # G:A:V:C:mainClass
		die "Too many elements in endpoint '$endpoint'"
		;;
	*:*:*:*:*) # G:A:V:C:mainClass
		g="${endpoint%%:*}"; remain="${endpoint#*:}"
		a="${remain%%:*}"; remain="${remain#*:}"
		v="${remain%%:*}"; remain="${remain#*:}"
		c="${remain%%:*}"
		mainClass="${remain#*:}"
		;;
	*:*:*:*) # G:A:V:mainClass
		g="${endpoint%%:*}"; remain="${endpoint#*:}"
		a="${remain%%:*}"; remain="${remain#*:}"
		v="${remain%%:*}"
		mainClass="${remain#*:}"
		;;
	*:*:*) # G:A:mainClass or G:A:V
		g="${endpoint%%:*}"; remain="${endpoint#*:}"
		a="${remain%%:*}"; remain="${remain#*:}"
		case "$remain" in
			[0-9]*|RELEASE|LATEST)
				v="$remain"
				;;
			*)
				v="RELEASE"
				mainClass="$remain"
				;;
		esac
		;;
	*:*) # G:A
		g="${endpoint%%:*}"
		a="${endpoint#*:}"
		v="RELEASE"
		;;
	*)
		echo "Usage: jrun <jvm-args> <endpoint> <main-args>"
		echo
		echo "Where <jvm-args> is any list of arguments to the JVM,"
		echo "and <main-args> is any list of arguments to the main class,"
		echo "and <endpoint> has one of the following formats:"
		echo
		echo "- groupId:artifactId"
		echo "- groupId:artifactId:version"
		echo "- groupId:artifactId:mainClass"
		echo "- groupId:artifactId:version:mainClass"
		echo "- groupId:artifactId:version:classifier:mainClass"
		echo
		echo "If version is omitted, then RELEASE is used."
		echo "If mainClass is omitted, it is auto-detected."
		exit 1
		;;
esac

dep="<groupId>$g</groupId><artifactId>$a</artifactId><version>$v</version>"
test -n "$c" && dep="$dep<classifier>$c</classifier>"

# Synthesize a dummy Maven project.

tmpDir=$(mktemp -d -t jrunXXX)

for repository in "${repositories[@]}"
do
	key=$(trim "${repository%=*}")
	val=$(trim "${repository#*=}")
	test -z "$repoBlock" && repoBlock="<repositories>"
	repoBlock="$repoBlock<repository><id>$key</id><url>$val</url></repository>"
done
test -n "$repoBlock" && repoBlock="$repoBlock</repositories>"


tmpPOM="$tmpDir/pom.xml"
cat >"$tmpPOM" <<EOL
<project>
	<modelVersion>4.0.0</modelVersion>
	<groupId>$g-BOOTSTRAPPER</groupId>
	<artifactId>$a-BOOTSTRAPPER</artifactId>
	<version>0</version>
	<dependencies>
		<dependency>$dep</dependency>
	</dependencies>
	$repoBlock
</project>
EOL

tmpLog="$tmpDir/build.log"
mvn -f "$tmpPOM" -DoutputDirectory="$tmpDir" dependency:copy-dependencies \
	>"$tmpLog" 2>&1
if [ $? -ne 0 ]
then
	echo "Failed to bootstrap the artifact. Here is the log:" >&2
	cat "$tmpLog" >&2
	exit 2
fi

# Infer and/or autocomplete the main class if necessary.

jarPathPrefix="$tmpDir/$a"
test -n "$c" && jarPathPrefix="$jarPathPrefix-$c"

if [ -z "$mainClass" ]
then
	# Check the JAR manifest.
	mainClass=$(tar xfO "$jarPathPrefix"-[0-9]*.jar META-INF/MANIFEST.MF 2>/dev/null |
		grep Main-Class | head -n1 | sed 's/^Main-Class: *\([a-zA-Z0-9_\.]*\).*/\1/')
	echo "Inferred main class: $mainClass"
fi
test -n "$mainClass" || die "No main class given, and none found."

mainPath="${mainClass//\./\/}"
completedClass="$(for jar in "$tmpDir/"*.jar; do tar tf "$jar"; done |
	grep "$mainPath.*\.class$" | head -n1 | sed 's/\.class$//')"
completedClass="${completedClass//\//.}"
if [ -n "$completedClass" -a "$completedClass" != "$mainClass" ]
then
	mainClass="${completedClass}"
	echo "Autocompleted main class: $mainClass"
fi

# Launch it!

java -cp "$tmpDir/*" "${jvm_args[@]}" "$mainClass" "${app_args[@]}"

# Clean up.

rm -rf "$tmpDir"
